-- -------------------------------------------------------------
-- 
-- File Name: C:\Git\rfsoc_ofdm\boards\ip\models\hdl_prj\OFDM_rx\hdlsrc\OFDM_Rx_HW\ofdm_rx_src_OFDMRx.vhd
-- Created: 2021-02-25 17:36:53
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 2.60417e-09
-- Target subsystem base rate: 8.33333e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        8.33333e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- m_axis_tdata                  ce_out        8.33333e-08
-- m_axis_tvalid                 ce_out        8.33333e-08
-- m_axis_chEst_tdata            ce_out        8.33333e-08
-- m_axis_chEst_tvalid           ce_out        8.33333e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ofdm_rx_src_OFDMRx
-- Source Path: OFDM_Rx_HW/OFDMRx
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ofdm_rx_src_OFDMRx_pkg.ALL;

ENTITY ofdm_rx_src_OFDMRx IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        s_axis_tdata                      :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        s_axis_tvalid                     :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        m_axis_tdata                      :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        m_axis_tvalid                     :   OUT   std_logic;
        m_axis_chEst_tdata                :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        m_axis_chEst_tvalid               :   OUT   std_logic
        );
END ofdm_rx_src_OFDMRx;


ARCHITECTURE rtl OF ofdm_rx_src_OFDMRx IS

  -- Component Declarations
  COMPONENT ofdm_rx_src_OFDMRx_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb_1_32_0                      :   OUT   std_logic;
          enb_1_32_1                      :   OUT   std_logic;
          enb_1_384_0                     :   OUT   std_logic;
          enb_1_384_1                     :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_Synchronisation
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_32_0                      :   IN    std_logic;
          enb_1_384_1                     :   IN    std_logic;
          enb_1_384_0                     :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataIn_im                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          DataOut_re                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          DataOut_im                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          FFTValidOut                     :   OUT   std_logic;
          dataValid                       :   OUT   std_logic;
          preambleValid                   :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_FFT
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_384_0                     :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataIn_im                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          FFTValidIn                      :   IN    std_logic;
          dataValid                       :   IN    std_logic;
          preambleValid                   :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataOut_im                      :   OUT   std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataValidOut                    :   OUT   std_logic;
          preambleValidOut                :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_ChannelEstEq
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_32_0                      :   IN    std_logic;
          enb_1_384_1                     :   IN    std_logic;
          enb_1_384_0                     :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataIn_im                       :   IN    std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataValid                       :   IN    std_logic;
          preambleValid                   :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataOut_im                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidOut                    :   OUT   std_logic;
          chEstData                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
          chEstValid                      :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_PhaseTracking_1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_32_0                      :   IN    std_logic;
          enb_1_384_1                     :   IN    std_logic;
          enb_1_384_0                     :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataIn_im                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidIn                     :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataOut_im                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidOut                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_PhaseTracking_2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_32_0                      :   IN    std_logic;
          enb_1_384_1                     :   IN    std_logic;
          enb_1_384_0                     :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataIn_im                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidIn                     :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataOut_im                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : ofdm_rx_src_OFDMRx_tc
    USE ENTITY work.ofdm_rx_src_OFDMRx_tc(rtl);

  FOR ALL : ofdm_rx_src_Synchronisation
    USE ENTITY work.ofdm_rx_src_Synchronisation(rtl);

  FOR ALL : ofdm_rx_src_FFT
    USE ENTITY work.ofdm_rx_src_FFT(rtl);

  FOR ALL : ofdm_rx_src_ChannelEstEq
    USE ENTITY work.ofdm_rx_src_ChannelEstEq(rtl);

  FOR ALL : ofdm_rx_src_PhaseTracking_1
    USE ENTITY work.ofdm_rx_src_PhaseTracking_1(rtl);

  FOR ALL : ofdm_rx_src_PhaseTracking_2
    USE ENTITY work.ofdm_rx_src_PhaseTracking_2(rtl);

  -- Signals
  SIGNAL enb_1_32_0                       : std_logic;
  SIGNAL enb_1_384_1                      : std_logic;
  SIGNAL enb_1_384_0                      : std_logic;
  SIGNAL enb_1_32_1                       : std_logic;
  SIGNAL s_axis_tdata_unsigned            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice_out1                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Bit_Slice1_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Data_Type_Conversion_out1_re     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data_Type_Conversion_out1_im     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Downsample_out1_re               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Downsample_out1_im               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Downsample_out1_re_1             : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Downsample_out1_im_1             : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Synchronisation_out1_re          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Synchronisation_out1_im          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Synchronisation_out2             : std_logic;
  SIGNAL Synchronisation_out3             : std_logic;
  SIGNAL Synchronisation_out4             : std_logic;
  SIGNAL FFT_out1_re                      : std_logic_vector(21 DOWNTO 0);  -- ufix22
  SIGNAL FFT_out1_im                      : std_logic_vector(21 DOWNTO 0);  -- ufix22
  SIGNAL FFT_out2                         : std_logic;
  SIGNAL FFT_out3                         : std_logic;
  SIGNAL ChannelEstEq_out1_re             : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL ChannelEstEq_out1_im             : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL ChannelEstEq_out2                : std_logic;
  SIGNAL y                                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL ChannelEstEq_out4                : std_logic;
  SIGNAL PhaseTracking_1_out1_re          : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL PhaseTracking_1_out1_im          : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL PhaseTracking_1_out2             : std_logic;
  SIGNAL PhaseTracking_2_out1_re          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL PhaseTracking_2_out1_im          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL PhaseTracking_2_out2             : std_logic;
  SIGNAL Repeat_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Repeat_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Bit_Concat_out1                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Upsample_zero                    : std_logic;
  SIGNAL Upsample_muxout                  : std_logic;
  SIGNAL Upsample_bypass_reg              : std_logic;  -- ufix1
  SIGNAL Upsample_bypassout               : std_logic;
  SIGNAL Upsample_int_delay_reg           : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL Upsample_out1                    : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 12);  -- ufix1 [13]
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Repeat1_out1                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL delayMatch1_reg                  : vector_of_unsigned32(0 TO 48);  -- ufix32 [49]
  SIGNAL Delay2_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Upsample1_zero                   : std_logic;
  SIGNAL Upsample1_muxout                 : std_logic;
  SIGNAL Upsample1_bypass_reg             : std_logic;  -- ufix1
  SIGNAL Upsample1_bypassout              : std_logic;
  SIGNAL Upsample1_int_delay_reg          : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL Upsample1_out1                   : std_logic;
  SIGNAL delayMatch2_reg                  : std_logic_vector(0 TO 48);  -- ufix1 [49]
  SIGNAL Delay1_out1                      : std_logic;

BEGIN
  -- Phase Tracking
  -- 
  -- One Tap Equaliser 
  -- 
  -- FFT Demodulation
  -- 
  -- Timing and Frequency 
  -- synchronisation  
  -- 
  -- Q0, I0
  -- 
  -- I0
  -- 
  -- Q0

  u_OFDMRx_tc : ofdm_rx_src_OFDMRx_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb_1_32_0 => enb_1_32_0,
              enb_1_32_1 => enb_1_32_1,
              enb_1_384_0 => enb_1_384_0,
              enb_1_384_1 => enb_1_384_1
              );

  u_Synchronisation : ofdm_rx_src_Synchronisation
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_32_0 => enb_1_32_0,
              enb_1_384_1 => enb_1_384_1,
              enb_1_384_0 => enb_1_384_0,
              dataIn_re => std_logic_vector(Downsample_out1_re_1),  -- sfix16_En14
              dataIn_im => std_logic_vector(Downsample_out1_im_1),  -- sfix16_En14
              DataOut_re => Synchronisation_out1_re,  -- sfix16_En14
              DataOut_im => Synchronisation_out1_im,  -- sfix16_En14
              FFTValidOut => Synchronisation_out2,
              dataValid => Synchronisation_out3,
              preambleValid => Synchronisation_out4
              );

  u_FFT : ofdm_rx_src_FFT
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_384_0 => enb_1_384_0,
              dataIn_re => Synchronisation_out1_re,  -- sfix16_En14
              dataIn_im => Synchronisation_out1_im,  -- sfix16_En14
              FFTValidIn => Synchronisation_out2,
              dataValid => Synchronisation_out3,
              preambleValid => Synchronisation_out4,
              dataOut_re => FFT_out1_re,  -- sfix22_En14
              dataOut_im => FFT_out1_im,  -- sfix22_En14
              dataValidOut => FFT_out2,
              preambleValidOut => FFT_out3
              );

  u_ChannelEstEq : ofdm_rx_src_ChannelEstEq
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_32_0 => enb_1_32_0,
              enb_1_384_1 => enb_1_384_1,
              enb_1_384_0 => enb_1_384_0,
              dataIn_re => FFT_out1_re,  -- sfix22_En14
              dataIn_im => FFT_out1_im,  -- sfix22_En14
              dataValid => FFT_out2,
              preambleValid => FFT_out3,
              dataOut_re => ChannelEstEq_out1_re,  -- sfix18_En15
              dataOut_im => ChannelEstEq_out1_im,  -- sfix18_En15
              dataValidOut => ChannelEstEq_out2,
              chEstData => y,  -- uint32
              chEstValid => ChannelEstEq_out4
              );

  u_PhaseTracking_1 : ofdm_rx_src_PhaseTracking_1
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_32_0 => enb_1_32_0,
              enb_1_384_1 => enb_1_384_1,
              enb_1_384_0 => enb_1_384_0,
              dataIn_re => ChannelEstEq_out1_re,  -- sfix18_En15
              dataIn_im => ChannelEstEq_out1_im,  -- sfix18_En15
              dataValidIn => ChannelEstEq_out2,
              dataOut_re => PhaseTracking_1_out1_re,  -- sfix18_En15
              dataOut_im => PhaseTracking_1_out1_im,  -- sfix18_En15
              dataValidOut => PhaseTracking_1_out2
              );

  u_PhaseTracking_2 : ofdm_rx_src_PhaseTracking_2
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_32_0 => enb_1_32_0,
              enb_1_384_1 => enb_1_384_1,
              enb_1_384_0 => enb_1_384_0,
              dataIn_re => PhaseTracking_1_out1_re,  -- sfix18_En15
              dataIn_im => PhaseTracking_1_out1_im,  -- sfix18_En15
              dataValidIn => PhaseTracking_1_out2,
              dataOut_re => PhaseTracking_2_out1_re,  -- sfix16_En14
              dataOut_im => PhaseTracking_2_out1_im,  -- sfix16_En14
              validOut => PhaseTracking_2_out2
              );

  s_axis_tdata_unsigned <= unsigned(s_axis_tdata);

  Bit_Slice_out1 <= s_axis_tdata_unsigned(15 DOWNTO 0);

  Bit_Slice1_out1 <= s_axis_tdata_unsigned(31 DOWNTO 16);

  Data_Type_Conversion_out1_re <= signed(Bit_Slice_out1);
  Data_Type_Conversion_out1_im <= signed(Bit_Slice1_out1);

  -- Downsample by 12 register (Sample offset 0)
  Downsample_output_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Downsample_out1_re <= to_signed(16#0000#, 16);
      Downsample_out1_im <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_384_1 = '1' THEN
        Downsample_out1_re <= Data_Type_Conversion_out1_re;
        Downsample_out1_im <= Data_Type_Conversion_out1_im;
      END IF;
    END IF;
  END PROCESS Downsample_output_process;


  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Downsample_out1_re_1 <= to_signed(16#0000#, 16);
      Downsample_out1_im_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_384_0 = '1' THEN
        Downsample_out1_re_1 <= Downsample_out1_re;
        Downsample_out1_im_1 <= Downsample_out1_im;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  Repeat_out1_im <= signed(PhaseTracking_2_out1_im);

  Repeat_out1_re <= signed(PhaseTracking_2_out1_re);

  Bit_Concat_out1 <= unsigned(Repeat_out1_im) & unsigned(Repeat_out1_re);

  m_axis_tdata <= std_logic_vector(Bit_Concat_out1);

  -- Upsample: Upsample by 12, Sample offset 5 
  Upsample_zero <= '0';

  
  Upsample_muxout <= PhaseTracking_2_out2 WHEN enb_1_384_1 = '1' ELSE
      Upsample_zero;

  -- Upsample bypass register
  Upsample_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Upsample_bypass_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_32_1 = '1' THEN
        Upsample_bypass_reg <= Upsample_muxout;
      END IF;
    END IF;
  END PROCESS Upsample_bypass_process;

  
  Upsample_bypassout <= Upsample_muxout WHEN enb_1_32_1 = '1' ELSE
      Upsample_bypass_reg;

  -- Upsample sample offset register
  Upsample_int_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Upsample_int_delay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_32_0 = '1' AND enb_1_32_0 = '1' THEN
        Upsample_int_delay_reg(0) <= Upsample_bypassout;
        Upsample_int_delay_reg(1 TO 4) <= Upsample_int_delay_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS Upsample_int_delay_process;

  Upsample_out1 <= Upsample_int_delay_reg(4);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_32_0 = '1' THEN
        delayMatch_reg(0) <= Upsample_out1;
        delayMatch_reg(1 TO 12) <= delayMatch_reg(0 TO 11);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Delay_out1 <= delayMatch_reg(12);

  Repeat1_out1 <= unsigned(y);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_32_0 = '1' THEN
        delayMatch1_reg(0) <= Repeat1_out1;
        delayMatch1_reg(1 TO 48) <= delayMatch1_reg(0 TO 47);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  Delay2_out1 <= delayMatch1_reg(48);

  m_axis_chEst_tdata <= std_logic_vector(Delay2_out1);

  -- Upsample1: Upsample by 12, Sample offset 5 
  Upsample1_zero <= '0';

  
  Upsample1_muxout <= ChannelEstEq_out4 WHEN enb_1_384_1 = '1' ELSE
      Upsample1_zero;

  -- Upsample bypass register
  Upsample1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Upsample1_bypass_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_32_1 = '1' THEN
        Upsample1_bypass_reg <= Upsample1_muxout;
      END IF;
    END IF;
  END PROCESS Upsample1_bypass_process;

  
  Upsample1_bypassout <= Upsample1_muxout WHEN enb_1_32_1 = '1' ELSE
      Upsample1_bypass_reg;

  -- Upsample sample offset register
  Upsample1_int_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Upsample1_int_delay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_32_0 = '1' AND enb_1_32_0 = '1' THEN
        Upsample1_int_delay_reg(0) <= Upsample1_bypassout;
        Upsample1_int_delay_reg(1 TO 4) <= Upsample1_int_delay_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS Upsample1_int_delay_process;

  Upsample1_out1 <= Upsample1_int_delay_reg(4);

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch2_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_32_0 = '1' THEN
        delayMatch2_reg(0) <= Upsample1_out1;
        delayMatch2_reg(1 TO 48) <= delayMatch2_reg(0 TO 47);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  Delay1_out1 <= delayMatch2_reg(48);

  ce_out <= enb_1_32_1;

  m_axis_tvalid <= Delay_out1;

  m_axis_chEst_tvalid <= Delay1_out1;

END rtl;

